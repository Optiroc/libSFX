<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>CPU.i</title>
<link rel="stylesheet" type="text/css" href="../styles/main.css">
</head><body class="ContentPage">

<div id=Content><div class="CFile"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="CPU.i"></a>CPU.i</h1><div class=CBody><!--START_ND_SUMMARY--><div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable><tr class="SMain"><td class=SEntry><a href="#CPU.i" >CPU.i</a></td><td class=SDescription></td></tr><tr class="SGroup"><td class=SEntry><a href="#RW*(register_width_macros)" >RW* (register width macros)</a></td><td class=SDescription>Instead of using ca65&rsquo;s .a* and .i* directives or the &ldquo;smart&rdquo; mode to set current register widths, libSFX uses these macros to track CPU state.</td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#proc" >proc</a></td><td class=SDescription>Define procedure with separate RW state</td></tr><tr class="SMacro SIndent1"><td class=SEntry><a href="#endproc" >endproc</a></td><td class=SDescription>End procedure and restore RW state</td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#RW_init" >RW_init</a></td><td class=SDescription>Define RW state variables in current scope</td></tr><tr class="SMacro SIndent1"><td class=SEntry><a href="#RW" >RW</a></td><td class=SDescription>Set accumulator/index register widths</td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#RW_assume" >RW_assume</a></td><td class=SDescription>Assume known accumulator/index register widths without emitting any instructions</td></tr><tr class="SMacro SIndent1"><td class=SEntry><a href="#RW_forced" >RW_forced</a></td><td class=SDescription>Force set accumulator/index register widths (ie. </td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#RW_assert" >RW_assert</a></td><td class=SDescription>Assert (at assemble time) that the specified register widths match with the state of the register tracking logic.</td></tr><tr class="SMacro SIndent1"><td class=SEntry><a href="#RW_push" >RW_push</a></td><td class=SDescription>Push current register widths state to the RW stack, and optionally set new state</td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#RW_pull" >RW_pull</a></td><td class=SDescription>Pull register widths state from the RW stack</td></tr><tr class="SMacro SIndent1"><td class=SEntry><a href="#RW_pull_forced" >RW_pull_forced</a></td><td class=SDescription>Pull register widths state from the RW stack, always emitting rep/sep instructions</td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#RW_print" >RW_print</a></td><td class=SDescription>Print (at assemble time) the current register widths state</td></tr><tr class="SMacro SIndent1"><td class=SEntry><a href="#RW_a_size" >RW_a_size()</a></td><td class=SDescription>Get the current accumlator register width</td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#RW_i_size" >RW_i_size()</a></td><td class=SDescription>Get the current index register width</td></tr><tr class="SGroup"><td class=SEntry><a href="#CPU_register_macros" >CPU register macros</a></td><td class=SDescription></td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#push" >push</a></td><td class=SDescription>Push CPU state to stack</td></tr><tr class="SMacro SIndent1"><td class=SEntry><a href="#pull" >pull</a></td><td class=SDescription>Pull CPU state from stack</td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#dbank" >dbank</a></td><td class=SDescription>Set data bank register (DB)</td></tr><tr class="SMacro SIndent1"><td class=SEntry><a href="#dpage" >dpage</a></td><td class=SDescription>Set direct page register (D)</td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#dpo" >dpo()</a></td><td class=SDescription>Get address minus current direct page offset</td></tr><tr class="SGroup"><td class=SEntry><a href="#CPU_meta_instructions" >CPU meta instructions</a></td><td class=SDescription></td></tr><tr class="SMetaInstructions SIndent1 SMarked"><td class=SEntry><a href="#bgt" >bgt</a></td><td class=SDescription>Branch if greater than</td></tr><tr class="SMetaInstructions SIndent1"><td class=SEntry><a href="#bsr" >bsr</a></td><td class=SDescription>Relative subroutine call</td></tr><tr class="SMetaInstructions SIndent1 SMarked"><td class=SEntry><a href="#bsl" >bsl</a></td><td class=SDescription>Relative long subroutine call</td></tr><tr class="SMetaInstructions SIndent1"><td class=SEntry><a href="#add" >add</a></td><td class=SDescription>Add (without carry)</td></tr><tr class="SMetaInstructions SIndent1 SMarked"><td class=SEntry><a href="#sub" >sub</a></td><td class=SDescription>Subtract (without carry)</td></tr><tr class="SMetaInstructions SIndent1"><td class=SEntry><a href="#asr" >asr</a></td><td class=SDescription>Arithmetic shift right</td></tr><tr class="SMetaInstructions SIndent1 SMarked"><td class=SEntry><a href="#neg" >neg</a></td><td class=SDescription>Negate (signed integer)</td></tr><tr class="SMetaInstructions SIndent1"><td class=SEntry><a href="#break" >break</a></td><td class=SDescription>Break debugger</td></tr></table></div></div><!--END_ND_SUMMARY--></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="RW*(register_width_macros)"></a>RW* (register width macros)</h3><div class=CBody><p>Instead of using ca65&rsquo;s .a* and .i* directives or the &ldquo;smart&rdquo; mode to set current register widths, libSFX uses these macros to track CPU state.</p><p>The main advantage of this approach is that rep/sep instructions will be emitted only when necessary.&nbsp; When relying a lot on &ldquo;function inlining&rdquo; via macros those tend to add up quickly.&nbsp; A bonus is that the state can be queried with the RW_a_size() and RW_i_size() macros, allowing for conditial assembly depending on register widths.</p><p>This tracking can only work within the same assembly unit, of course.&nbsp; When calling function over unit barriers there&rsquo;s an RW stack and a couple of helper macros to keep those pesky register sizes in sync.</p><h4 class=CHeading>Example</h4><blockquote><pre>.macro call_external
      RW_push set:a16             ;Push current state and set accumlator
                                  ;width to 16 bits if necessary
                                  ;Only if accumulator is 8 bits wide a
                                  ;rep #$20 instruction will be emitted

      jsl     external            ;Call external subroutine that assumes
                                  ;16-bit accumulator

      RW_pull                     ;Register widths are restored as needed
.endmac

The 'external' subroutine looks like this:

proc external, a16                ;16 bit accumulator is assumed (no instruction emitted)
      lda     #$f00d              ;So this will assemble nicely
      rtl
endproc</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="proc"></a>proc</h3><div class=CBody><p>Define procedure with separate RW state</p><p>This is equivalent to .proc directive, but ensures that using the RW* macros inside of the procedure does not affect tracking of CPU state anywhere outside of the procedure, and vice-versa.</p><p>It is recommended to use the &lsquo;proc&rsquo; and &lsquo;endproc&rsquo; macros instead of .proc and .endproc for any code using libSFX macros.</p><p>By default, code inside the procedure assumes 8-bit A and 16-bit X/Y (M=1, X=0).&nbsp; Optionally, you may specify other incoming register sizes as a parameter.</p><p>(See also: &lsquo;RW_init&rsquo;, &lsquo;RW_assume&rsquo;)</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    name      Procedure name
:in?:   widths    Register widths         a8/a16/i8/i16/a8i8/a16i16/a8i16/a16i8</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="endproc"></a>endproc</h3><div class=CBody><p>End procedure and restore RW state</p><p>This is the equivalent to .endproc corresponding with the &lsquo;proc&rsquo; macro.&nbsp; This ensures that the outer scope continues to track the correct register sizes regardless of any RW* macros which were used in the inner scope.</p></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_init"></a>RW_init</h3><div class=CBody><p>Define RW state variables in current scope</p><p>Used by all register width macros to ensure that register state can be tracked in any scope.&nbsp; This also means that code inside of a .proc or .scope will not affect tracked register widths for code in the global scope, and vice-versa.&nbsp; (Thus, the register widths inside a nested scope are always initially a8i16.)</p></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW"></a>RW</h3><div class=CBody><p>Set accumulator/index register widths</p><p>No-op if current state == intended state.</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    widths    Register widths         a8/a16/i8/i16/a8i8/a16i16/a8i16/a16i8</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_assume"></a>RW_assume</h3><div class=CBody><p>Assume known accumulator/index register widths without emitting any instructions</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    widths    Register widths         a8/a16/i8/i16/a8i8/a16i16/a8i16/a16i8</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_forced"></a>RW_forced</h3><div class=CBody><p>Force set accumulator/index register widths (ie. always emit rep/sep instructions)</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    widths    Register widths         a8/a16/i8/i16/a8i8/a16i16/a8i16/a16i8</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_assert"></a>RW_assert</h3><div class=CBody><p>Assert (at assemble time) that the specified register widths match with the state of the register tracking logic.</p><h4 class=CHeading>Parameters</h4><blockquote><pre>:in:    widths    Register widths         a8/a16/i8/i16/a8i8/a16i16/a8i16/a16i8
:in:    message   Error message           string</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_push"></a>RW_push</h3><div class=CBody><p>Push current register widths state to the RW stack, and optionally set new state</p><p>No-op if current state == intended state.</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in?:   widths    Register widths         a8/a16/i8/i16/a8i8/a16i16/a8i16/a16i8</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_pull"></a>RW_pull</h3><div class=CBody><p>Pull register widths state from the RW stack</p><p>No-op if current state == intended state.</p></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_pull_forced"></a>RW_pull_forced</h3><div class=CBody><p>Pull register widths state from the RW stack, always emitting rep/sep instructions</p><p>Might come in handy when calling a subroutine that returns with the register widths in an unknown state.</p></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_print"></a>RW_print</h3><div class=CBody><p>Print (at assemble time) the current register widths state</p></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_a_size"></a>RW_a_size()</h3><div class=CBody><p>Get the current accumlator register width</p><h4 class=CHeading>Returns</h4><blockquote><pre>0 = 16 bits
1 = 8 bits</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_i_size"></a>RW_i_size()</h3><div class=CBody><p>Get the current index register width</p><h4 class=CHeading>Returns</h4><blockquote><pre>0 = 16 bits
1 = 8 bits</pre></blockquote></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="CPU_register_macros"></a>CPU register macros</h3></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="push"></a>push</h3><div class=CBody><p>Push CPU state to stack</p></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="pull"></a>pull</h3><div class=CBody><p>Pull CPU state from stack</p></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="dbank"></a>dbank</h3><div class=CBody><p>Set data bank register (DB)</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    bank      Bank (uint8)            a/x/y       Requires RW a8 or i8
                                          constant    Using a</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="dpage"></a>dpage</h3><div class=CBody><p>Set direct page register (D)</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    offs      Offset (uint16)         a
                                          constant    Using a</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="dpo"></a>dpo()</h3><div class=CBody><p>Get address minus current direct page offset</p><p>Calculates a byte offset using the latest value set by the &lsquo;dpage&rsquo; macro.</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    addr      Address (uint16)        constant</pre></blockquote><h4 class=CHeading>Example</h4><blockquote><pre>dpage   INIDISP
stz     z:dpo(OBJSEL)           ;Reset OAM regs
stz     z:dpo(OAMADDL)
stz     z:dpo(OAMADDH)</pre></blockquote></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="CPU_meta_instructions"></a>CPU meta instructions</h3></div></div>

<div class="CMetaInstructions"><div class=CTopic><h3 class=CTitle><a name="bgt"></a>bgt</h3><div class=CBody><p>Branch if greater than</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    addr      Address</pre></blockquote></div></div></div>

<div class="CMetaInstructions"><div class=CTopic><h3 class=CTitle><a name="bsr"></a>bsr</h3><div class=CBody><p>Relative subroutine call</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    addr      Address</pre></blockquote></div></div></div>

<div class="CMetaInstructions"><div class=CTopic><h3 class=CTitle><a name="bsl"></a>bsl</h3><div class=CBody><p>Relative long subroutine call</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    addr      Address</pre></blockquote></div></div></div>

<div class="CMetaInstructions"><div class=CTopic><h3 class=CTitle><a name="add"></a>add</h3><div class=CBody><p>Add (without carry)</p><h4 class=CHeading>Parameters</h4><blockquote><pre>:in:    op        Operand
:in?:   ix        Index</pre></blockquote></div></div></div>

<div class="CMetaInstructions"><div class=CTopic><h3 class=CTitle><a name="sub"></a>sub</h3><div class=CBody><p>Subtract (without carry)</p><h4 class=CHeading>Parameters</h4><blockquote><pre>:in:    op        Operand
:in?:   ix        Index</pre></blockquote></div></div></div>

<div class="CMetaInstructions"><div class=CTopic><h3 class=CTitle><a name="asr"></a>asr</h3><div class=CBody><p>Arithmetic shift right</p></div></div></div>

<div class="CMetaInstructions"><div class=CTopic><h3 class=CTitle><a name="neg"></a>neg</h3><div class=CBody><p>Negate (signed integer)</p></div></div></div>

<div class="CMetaInstructions"><div class=CTopic><h3 class=CTitle><a name="break"></a>break</h3><div class=CBody><p>Break debugger</p><p>If assembled with debug=1 the break macro emits a &ldquo;wdm $00&rdquo; instruction, which can be set to trigger a break in the bsnes+ debugger.</p></div></div></div>

</div><!--Content-->

<div id=Footer>libSFX&nbsp; &middot;&nbsp; <a href="http://www.naturaldocs.org">Generated by Natural Docs</a></div><!--Footer-->

<div id=Menu><div class=MEntry><div class=MFile><a href="libSFX-i.html">libSFX documentation</a></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent1')">Configuration</a><div class=MGroupContent id=MGroupContent1><div class=MEntry><div class=MFile><a href="Docs/Make-txt.html">Make</a></div></div><div class=MEntry><div class=MFile><a href="Configurations/libSFX-cfg.html">libSFX.cfg</a></div></div><div class=MEntry><div class=MFile><a href="Configurations/Map-cfg.html">Map.cfg</a></div></div></div></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent2')">S-CPU</a><div class=MGroupContent id=MGroupContent2><div class=MEntry><div class=MFile id=MSelected>CPU</div></div><div class=MEntry><div class=MFile><a href="CPU_Def-i.html">CPU_Def</a></div></div><div class=MEntry><div class=MFile><a href="CPU_Memory-i.html">CPU_Memory</a></div></div><div class=MEntry><div class=MFile><a href="CPU_Math-i.html">CPU_Math</a></div></div><div class=MEntry><div class=MFile><a href="CPU_PPU-i.html">CPU_PPU</a></div></div><div class=MEntry><div class=MFile><a href="CPU_SMP-i.html">CPU_SMP</a></div></div><div class=MEntry><div class=MFile><a href="CPU_Runtime-i.html">CPU_Runtime</a></div></div><div class=MEntry><div class=MFile><a href="CPU_DataStructures-i.html">CPU_DataStructures</a></div></div></div></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent3')">S-SMP</a><div class=MGroupContent id=MGroupContent3><div class=MEntry><div class=MFile><a href="SMP_Def-i.html">SMP_Def</a></div></div><div class=MEntry><div class=MFile><a href="SMP_ADSR-i.html">SMP_ADSR</a></div></div><div class=MEntry><div class=MFile><a href="SMP_Util-i.html">SMP_Util</a></div></div></div></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent4')">Packages</a><div class=MGroupContent id=MGroupContent4><div class=MEntry><div class=MFile><a href="Packages/LZ4/LZ4-i.html">LZ4</a></div></div><div class=MEntry><div class=MFile><a href="Packages/Mouse/Mouse-i.html">Mouse</a></div></div></div></div></div></div><!--Menu-->


<!--START_ND_TOOLTIPS-->
<!--END_ND_TOOLTIPS-->



</body></html>