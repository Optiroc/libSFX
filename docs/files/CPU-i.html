<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">

<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>/Users/optiroc/Development/libSFX/include/CPU.i</title><link rel="stylesheet" type="text/css" href="../styles/main.css"><script language=JavaScript src="../javascript/main.js"></script><meta name="viewport" content="width=device-width, initial-scale=1.0" /><script language=JavaScript src="../javascript/searchdata.js"></script></head><body class="ContentPage"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version 1.52 -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org -->




<div id=Content><div class="CFile"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="CPU.i"></a>CPU.i</h1><div class=CBody><!--START_ND_SUMMARY--><div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable><tr class="SMain"><td class=SEntry><a href="#CPU.i" >CPU.i</a></td><td class=SDescription></td></tr><tr class="SGroup"><td class=SEntry><a href="#RW*(register_width_macros)" >RW* (register width macros)</a></td><td class=SDescription>Instead of using ca65&rsquo;s .a* and .i* directives or the &ldquo;smart&rdquo; mode to set current register widths, libSFX uses these macros to track CPU state.</td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#RW" >RW</a></td><td class=SDescription>Set accumulator/index register widths</td></tr><tr class="SMacro SIndent1"><td class=SEntry><a href="#RW_assume" >RW_assume</a></td><td class=SDescription>Assume known accumulator/index register widths without emitting any instructions</td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#RW_forced" >RW_forced</a></td><td class=SDescription>Force set accumulator/index register widths (ie. </td></tr><tr class="SMacro SIndent1"><td class=SEntry><a href="#RW_assert" >RW_assert</a></td><td class=SDescription>Assert (at assemble time) that the specified register widths match with the state of the register tracking logic.</td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#RW_push" >RW_push</a></td><td class=SDescription>Push current register widths state to the RW stack, and optionally set new state</td></tr><tr class="SMacro SIndent1"><td class=SEntry><a href="#RW_pull" >RW_pull</a></td><td class=SDescription>Pull register widths state from the RW stack</td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#RW_pull_forced" >RW_pull_forced</a></td><td class=SDescription>Pull register widths state from the RW stack, always emitting rep/sep instructions</td></tr><tr class="SMacro SIndent1"><td class=SEntry><a href="#RW_print" >RW_print</a></td><td class=SDescription>Print (at assemble time) the current register widths state</td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#RW_a_size" >RW_a_size()</a></td><td class=SDescription>Get the current accumlator register width</td></tr><tr class="SMacro SIndent1"><td class=SEntry><a href="#RW_i_size" >RW_i_size()</a></td><td class=SDescription>Get the current index register width</td></tr><tr class="SGroup"><td class=SEntry><a href="#CPU_register_macros" >CPU register macros</a></td><td class=SDescription></td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#push" >push</a></td><td class=SDescription>Push CPU state to stack</td></tr><tr class="SMacro SIndent1"><td class=SEntry><a href="#pull" >pull</a></td><td class=SDescription>Pull CPU state from stack</td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#dbank" >dbank</a></td><td class=SDescription>Set data bank register (DB)</td></tr><tr class="SMacro SIndent1"><td class=SEntry><a href="#dpage" >dpage</a></td><td class=SDescription>Set direct page register (D)</td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#dpo" >dpo()</a></td><td class=SDescription>Get address minus current direct page offset</td></tr><tr class="SGroup"><td class=SEntry><a href="#CPU_meta_instructions" >CPU meta instructions</a></td><td class=SDescription></td></tr><tr class="SMetaInstructions SIndent1 SMarked"><td class=SEntry><a href="#bgt" >bgt</a></td><td class=SDescription>Branch if greater than</td></tr><tr class="SMetaInstructions SIndent1"><td class=SEntry><a href="#bsr" >bsr</a></td><td class=SDescription>Relative subroutine call</td></tr><tr class="SMetaInstructions SIndent1 SMarked"><td class=SEntry><a href="#bsl" >bsl</a></td><td class=SDescription>Relative long subroutine call</td></tr><tr class="SMetaInstructions SIndent1"><td class=SEntry><a href="#add" >add</a></td><td class=SDescription>Add (without carry)</td></tr><tr class="SMetaInstructions SIndent1 SMarked"><td class=SEntry><a href="#sub" >sub</a></td><td class=SDescription>Subtract (without carry)</td></tr><tr class="SMetaInstructions SIndent1"><td class=SEntry><a href="#asr" >asr</a></td><td class=SDescription>Arithmetic shift right</td></tr><tr class="SMetaInstructions SIndent1 SMarked"><td class=SEntry><a href="#neg" >neg</a></td><td class=SDescription>Negate (signed integer)</td></tr><tr class="SMetaInstructions SIndent1"><td class=SEntry><a href="#break" >break</a></td><td class=SDescription>Break debugger</td></tr></table></div></div><!--END_ND_SUMMARY--></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="RW*(register_width_macros)"></a>RW* (register width macros)</h3><div class=CBody><p>Instead of using ca65&rsquo;s .a* and .i* directives or the &ldquo;smart&rdquo; mode to set current register widths, libSFX uses these macros to track CPU state.</p><p>The main advantage of this approach is that rep/sep instructions will be emitted only when necessary.&nbsp; When relying a lot on &ldquo;function inlining&rdquo; via macros those tend to add up quickly.&nbsp; A bonus is that the state can be queried with the RW_a_size() and RW_i_size() macros, allowing for conditial assembly depending on register widths.</p><p>This tracking can only work within the same assembly unit, of course.&nbsp; When calling function over unit barriers there&rsquo;s an RW stack and a couple of helper macros to keep those pesky register sizes in sync.</p><h4 class=CHeading>Example</h4><blockquote><pre class="prettyprint">.macro call_external
      RW_push set:a16             ;Push current state and set accumlator
                                  ;width to 16 bits if necessary
                                  ;Only if accumulator is 8 bits wide a
                                  ;rep #$20 instruction will be emitted

      jsl     external            ;Call external subroutine that assumes
                                  ;16-bit accumulator

      RW_pull                     ;Register widths are restored as needed
.endmac

The 'external' subroutine looks like this:

.proc external
      RW_assume a16               ;16 bit accumulator is assumed
                                  ;(no instruction emitted)
      lda     #$f00d              ;So this will assemble nicely
      rtl
.endproc</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW"></a>RW</h3><div class=CBody><p>Set accumulator/index register widths</p><p>No-op if current state == intended state.</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    widths    Register widths         a8/a16/i8/i16/a8i8/a16i16/a8i16/a16i8</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_assume"></a>RW_assume</h3><div class=CBody><p>Assume known accumulator/index register widths without emitting any instructions</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    widths    Register widths         a8/a16/i8/i16/a8i8/a16i16/a8i16/a16i8</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_forced"></a>RW_forced</h3><div class=CBody><p>Force set accumulator/index register widths (ie. always emit rep/sep instructions)</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    widths    Register widths         a8/a16/i8/i16/a8i8/a16i16/a8i16/a16i8</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_assert"></a>RW_assert</h3><div class=CBody><p>Assert (at assemble time) that the specified register widths match with the state of the register tracking logic.</p><h4 class=CHeading>Parameters</h4><blockquote><pre>:in:    widths    Register widths         a8/a16/i8/i16/a8i8/a16i16/a8i16/a16i8
:in:    message   Error message           string</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_push"></a>RW_push</h3><div class=CBody><p>Push current register widths state to the RW stack, and optionally set new state</p><p>No-op if current state == intended state.</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in?:   widths    Register widths         a8/a16/i8/i16/a8i8/a16i16/a8i16/a16i8</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_pull"></a>RW_pull</h3><div class=CBody><p>Pull register widths state from the RW stack</p><p>No-op if current state == intended state.</p></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_pull_forced"></a>RW_pull_forced</h3><div class=CBody><p>Pull register widths state from the RW stack, always emitting rep/sep instructions</p><p>Might come in handy when calling a subroutine that returns with the register widths in an unknown state.</p></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_print"></a>RW_print</h3><div class=CBody><p>Print (at assemble time) the current register widths state</p></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_a_size"></a>RW_a_size()</h3><div class=CBody><p>Get the current accumlator register width</p><h4 class=CHeading>Returns</h4><blockquote><pre>0 = 16 bits
1 = 8 bits</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="RW_i_size"></a>RW_i_size()</h3><div class=CBody><p>Get the current index register width</p><h4 class=CHeading>Returns</h4><blockquote><pre>0 = 16 bits
1 = 8 bits</pre></blockquote></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="CPU_register_macros"></a>CPU register macros</h3></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="push"></a>push</h3><div class=CBody><p>Push CPU state to stack</p></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="pull"></a>pull</h3><div class=CBody><p>Pull CPU state from stack</p></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="dbank"></a>dbank</h3><div class=CBody><p>Set data bank register (DB)</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    bank      Bank (uint8)            a/x/y       Requires RW a8 or i8
                                          constant    Using a</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="dpage"></a>dpage</h3><div class=CBody><p>Set direct page register (D)</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    offs      Offset (uint16)         a
                                          constant    Using a</pre></blockquote></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="dpo"></a>dpo()</h3><div class=CBody><p>Get address minus current direct page offset</p><p>Calculates a byte offset using the latest value set by the &lsquo;dpage&rsquo; macro.</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    addr      Address (uint16)        constant</pre></blockquote><h4 class=CHeading>Example</h4><blockquote><pre class="prettyprint">dpage   INIDISP
stz     z:dpo(OBJSEL)           ;Reset OAM regs
stz     z:dpo(OAMADDL)
stz     z:dpo(OAMADDH)</pre></blockquote></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="CPU_meta_instructions"></a>CPU meta instructions</h3></div></div>

<div class="CMetaInstructions"><div class=CTopic><h3 class=CTitle><a name="bgt"></a>bgt</h3><div class=CBody><p>Branch if greater than</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    addr      Address</pre></blockquote></div></div></div>

<div class="CMetaInstructions"><div class=CTopic><h3 class=CTitle><a name="bsr"></a>bsr</h3><div class=CBody><p>Relative subroutine call</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    addr      Address</pre></blockquote></div></div></div>

<div class="CMetaInstructions"><div class=CTopic><h3 class=CTitle><a name="bsl"></a>bsl</h3><div class=CBody><p>Relative long subroutine call</p><h4 class=CHeading>Parameter</h4><blockquote><pre>:in:    addr      Address</pre></blockquote></div></div></div>

<div class="CMetaInstructions"><div class=CTopic><h3 class=CTitle><a name="add"></a>add</h3><div class=CBody><p>Add (without carry)</p><h4 class=CHeading>Parameters</h4><blockquote><pre>:in:    op        Operand
:in?:   ix        Index</pre></blockquote></div></div></div>

<div class="CMetaInstructions"><div class=CTopic><h3 class=CTitle><a name="sub"></a>sub</h3><div class=CBody><p>Subtract (without carry)</p><h4 class=CHeading>Parameters</h4><blockquote><pre>:in:    op        Operand
:in?:   ix        Index</pre></blockquote></div></div></div>

<div class="CMetaInstructions"><div class=CTopic><h3 class=CTitle><a name="asr"></a>asr</h3><div class=CBody><p>Arithmetic shift right</p></div></div></div>

<div class="CMetaInstructions"><div class=CTopic><h3 class=CTitle><a name="neg"></a>neg</h3><div class=CBody><p>Negate (signed integer)</p></div></div></div>

<div class="CMetaInstructions"><div class=CTopic><h3 class=CTitle><a name="break"></a>break</h3><div class=CBody><p>Break debugger</p><p>If assembled with debug=1 the break macro emits a &ldquo;wdm $00&rdquo; instruction, which can be set to trigger a break in the bsnes+ debugger.</p></div></div></div>

</div><!--Content-->


<div id=Footer>libSFX&nbsp; &middot;&nbsp; <a href="http://www.naturaldocs.org">Generated by Natural Docs</a></div><!--Footer-->


<div id=Menu><div class=MEntry><div class=MFile><a href="libSFX-i.html">libSFX documentation</a></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent1')">S-CPU</a><div class=MGroupContent id=MGroupContent1><div class=MEntry><div class=MFile id=MSelected>CPU</div></div><div class=MEntry><div class=MFile><a href="CPU_Def-i.html">CPU_Def</a></div></div><div class=MEntry><div class=MFile><a href="CPU_Memory-i.html">CPU_Memory</a></div></div><div class=MEntry><div class=MFile><a href="CPU_Math-i.html">CPU_Math</a></div></div><div class=MEntry><div class=MFile><a href="CPU_PPU-i.html">CPU_PPU</a></div></div><div class=MEntry><div class=MFile><a href="CPU_SMP-i.html">CPU_SMP</a></div></div><div class=MEntry><div class=MFile><a href="CPU_Runtime-i.html">CPU_Runtime</a></div></div><div class=MEntry><div class=MFile><a href="CPU_Compression-i.html">CPU_Compression</a></div></div><div class=MEntry><div class=MFile><a href="CPU_DataStructures-i.html">CPU_DataStructures</a></div></div></div></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent2')">S-SMP</a><div class=MGroupContent id=MGroupContent2><div class=MEntry><div class=MFile><a href="SMP_Def-i.html">SMP_Def</a></div></div><div class=MEntry><div class=MFile><a href="SMP_Util-i.html">SMP_Util</a></div></div></div></div></div></div><!--Menu-->



<!--START_ND_TOOLTIPS-->
<!--END_ND_TOOLTIPS-->




<div id=MSearchResultsWindow><iframe src="" frameborder=0 name=MSearchResults id=MSearchResults></iframe><a href="javascript:searchPanel.CloseResultsWindow()" id=MSearchResultsWindowClose>Close</a></div>


<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>
